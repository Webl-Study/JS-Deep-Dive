# 원시 값과 객체의 비교

- 얕은 복사 = 참조 주소를 복사
- 깊은 복사 = 원시 값 자체를 복사

얕은 복사는 참조 값이 공유되어 사이드 이펙트를 불러일으킬 수 있다.(변동 가능성이 있음)<br>
깊은 복사는 새로운 메모리에 새로 생성하는 것!
<br>

### immutable & mutable 메서드

slice와 splice 메서드의 차이점은 무엇일까요?<br>
<br>
splice는 원본을 mutable 시켜버림(원본을 변형시켜버림)<br>
slice는 얕은 복사<br>
<br>

forEach와 map, filter의 차이점은 무엇일까요?<br>
<br>
forEach는 단순 반복<br>
map, filter는 새로운 배열을 얕은 복사로 반환한다!
<br>

immtable한 모든 메서드는 얕은 복사!<br>
깊은 복사를 하려면 재귀를 타야해서 성능적으로 좋지 않기 때문에 immutable한 모든 메서드들은 얕은 복사를 사용한다.<br>
<br>
mutable 함수는 복사가 없으니까 성능적으로 더 좋지만, 실무에서는 안전한 immutable 메서드를 많이 사용함

<br>
깊은 복사는? 언제 사용하는게 좋은가?<br>
객체 자체를 여러 군데에서 사용할 때? => 다른 케이스도 찾아보기<br>
<br>

**원시 값을 변수에 할당**하면 변수(확보된 메모리 공간)에는 **실제 값이 저장**<br>
**객체를 변수에 할당**하면 변수(확보된 메모리 공간)에는 **참조 값이 저장**<br>

- **값에 의한 전달** : 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 **원시 값이 복사**되어 전달
- **참조에 의한 전달** : 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 **참조 값이 복사**되어 전달
  <br>

## 원시 값

### 1. 변경 불가능한 값

**원시 값은 변경 불가능한 값.**

- 변수 : 하나의 값을 저장하기 위해 확보한 **메모리 공간** 자체
- 값 : **변수에 저장된 데이터**로서 **표현식이 평가되어 생성된 결과**

**변경 불가능 하다는 것은 변수가 아니라 값에 대한 진술**이다.
<br>
<br>

상수는 단 한 번만 할당이 허용되므로, 변수 값을 변경(교체)할 수 없다.<br>
상수와 변경 불가능한 값을 동일시 하는 것은 곤란하다. **상수는 재할당이 금지된 변수**일 뿐이다.<br>
<br>

원시 값은 변경 불가능한 값이기 때문에 값을 직접 변경할 수 없다.<br>
**불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.**<br>

- 불변성 : 새로운 메모리 공간을 확보하고 재할당한 값을 저장한 후, 변수가 참조하던 메모리 공간의 주소를 변경하는 값의 특성
  <br>

### 2. 문자열과 불변성

문자열은 유사 배열 객체이면서 이터러블이므로 배열과 유사하게 각 문자에 접근할 수 있다.

- 유사 배열 객체 : 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체

한 번 생성된 문자열은 읽기 전용 값으로서 변경할 수 없다.<br>
그러나 변수에 새로운 문자열을 재할당하는 것은 물론 가능하다. 이는 기존 문자열을 변경하는 것이 아니라 새로운 문자열을 새롭게 할당하는 것이기 때문이다.<br>
<br>
<br>

### 3. 값에 의한 전달

변수에 원시 값을 갖는 변수를 할당하면,<br>
할당 받는 변수와 할당되는 변수의 **값은 동일**하지만, **다른 메모리 공간에 저장된 별개의 값**이다.

**엄격하게 표현하면 변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달 되는 것!** <br>

변수와 같은 **식별자는 값이 아니라 메모리 주소를 기억**하고 있다.<br>
식별자로 값을 구별해서 식별한다는 것 = 식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값에 접근할 수 있다는 것
<br>

중요한 것은!<br>
변수에 원시 값을 갖는 변수를 할당하면 변수 할당 시점이든, 두 변수 중 어느 하나의 변수에 값을 재할당하는 시점이든<br>
결국은 **두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값**이 되어 어느 한 쪽에서 재할당을 통해 값을 변경하더라도 **서로 간섭할 수 없다는 것!!!**
<br>
<br>

## 객체

**확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다.** <br>
객체는 프로퍼티의 개수가 정해져 있지 않으며, 동적으로 추가되고 삭제할 수 있고, 프로퍼티의 값에도 제약이 없기 때문! <br>
<br>

**자바스크립트는 클래스 없이 객체를 생성할 수 있으며, 객체가 생성된 이후라도 동적으로 프로퍼티와 메서드를 추가할 수 있다.** <br>
사용하기 매우 편리하지만, 성능 면에서는 이론적으로 **클래스 기반 객체지향 프로그래밍 언어의 객체보다 생성과 프로퍼티 접근에 비용이 더 많이 드는** 비효율적인 방식.

V8 자바스크립트 엔진에서는 프로퍼티에 접근하기 위해 동적 탐색 대신 **히든 클래스**라는 방식을 사용한다.
<br>
<br>

### 변경 가능한 값

**객체는 변경 가능한 값**이다. 따라서 객체를 할당한 변수는 **재할당 없이 객체를 직접 변경**할 수 있다.<br>
이때, 재할당을 하지 않았으므로 **객체를 할당한 변수의 참조 값은 변경되지 않는다.** <br>
<br>
**재할당 없이 프로퍼티를 동적으로 추가할 수도 있고 프로퍼티 값을 갱신할 수도 있으며 프로퍼티 자체를 삭제할 수도 있다.** <br>

원시 값을 할당한 변수는 원시 값 자체를 값으로 갖는다. <br>
객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 참조 값에 접근할 수 있다. <br>

- 참조 값 : 생성된 객체가 저장된 메모리 주소

원시 값을 할당한 변수를 참조하면 메모리에 저장되어 있는 원시 값에 접근한다. <br>
**객체를 할당한 변수를 참조하면 메모리에 저장되어 있는 참조 값을 통해 실제 객체에 접근** 한다. <br>
<br>

//<br>
**객체를 생성하고 관리하는 방식은 매우 복잡하며 비용이 많이 드는 일**이다. <br>
객체를 변경할 때마다 원시 값처럼 값을 복사해서 새롭게 생성한다면 신뢰성이 확보되겠지만, **객체는 원시 값처럼 크기가 일정하지 않고 프로퍼티 값이 객체일 수도 있어서 복사해서 생성하는 비용이 많이 든다.**

따라서, **메모리를 효율적으로 사용**하기 위해, **객체를 복사해 생성하는 비용을 절약하여 성능을 향상**시키기 위해 **객체는 변경 가능한 값으로 설계** 되어 있다. <br>
이러한 구조적 단점에 따라, **객체는** 원시 값과 다르게 **여러 개의 식별자가 하나의 객체를 공유할 수 있다는 부작용**이 있다. <br>
<br>

#### 얕은 복사와 깊은 복사

- 얕은 복사 : 한 단계까지만 복사. (객체에 중첩되어 있는 객체의 경우 참조 값을 복사)
- 깊은 복사 : 객체에 중첩되어 있는 객체까지 모두 복사. (원시 값처럼 완전한 복사본을 만든다.)
  <br>

### 참조에 의한 전달

여러개의 식별자가 하나의 객체를 공유할 수 있어 발생하는 부작용

참조에 의한 전달 : **객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달되는 것**

**원본과 사본은 저장된 메모리 주소는 다르지만 동일한 참조 값을 갖는다.** <br>
다시 말해, **원본과 사본 모두 동일한 객체를 가리킨다 = 두 개의 식별자가 하나의 객체를 공유** <br>
원본 또는 사본 중 어느 한 쪽에서 객체를 변경(변수에 새로운 객체를 재할당하는 것이 아니라 객체의 프로퍼티 값을 변경하거나 프로퍼티를 추가, 삭제)하면 서로 영향을 주고 받는다.
<br>
<br>

값에 의한 전달과 참조에 의한 전달은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일 <br>
다만, **식별자가 기억하는 메모리 공간**, 즉 **변수에 저장되어 있는 값이 원시 값이냐 참조 값이냐의 차이**만 있을 뿐 <br>
따라서, 자바스크립트에는 '참조에 의한 전달'은 존재하지 않고 **'값에 의한 전달'만이 존재한다**고 말할 수 있다. <br>
<br>

자바스크립트에는 포인터가 존재하지 않기 때문에 포인터가 존재하는 **다른 프로그래밍 언어의 '참조에 의한 전달'과 의미가 정확히 일치하지 않는다는 점을 주의!**

다른 프로그래밍 언어는 식별자를 거치지 않고 포인터로 직접 메모리 주소에 접근할 수 있다.
<br>
