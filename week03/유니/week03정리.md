# 🐱 프로퍼티 어트리뷰트

### 내부 슬롯과 내부 메서드

- 내부 슬롯과 내부 메서드는 자바스크립트 엔진에서 실제로 동작하지만 개발자가 직접 접근할 수 있도록 외부로 공개된 객체의 프로퍼티는 아니다.
- 즉, 자바스크립트 엔진의 내부 로직
- 모든 객체는 [[Prototype]]이라는 내부 슬롯을 갖는다. 직접 접근할 수 없지만 **proto**를 통해 간접적으로 접근할 수 있다.

### 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체

- 자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다.
- 프로퍼티의 상태란 프로퍼티의 값, 값의 갱신 가능 여부, 열거 가능 여부, 재정의 가능 여부를 말한다.
- 프로퍼티 어트리뷰트에 직접 접근할 수 없고, Object.getOwnPropertyDescriptor 메서드를 사용해서 간접적으로 확인한다.

### 데이터 프로퍼티와 접근자 프로퍼티

- 프로퍼티는 데이터 프로퍼티와 접근자 프로퍼티로 구분할 수 있다.
- 데이터 프로퍼티 : 키와 값으로 구성된 일반적인 프로퍼티다.
- 접근자 프로퍼티 : 자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티다.
- 데이터 프로퍼티는 4개의 어트리뷰트를 갖는다. [[Value]], [[Writable]], [[Enumerable]], [[Configurable]]
- 접근자 프로퍼티는 자체적으로 값을 가지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수로 구성된 프로퍼티다. -> getter/setter 함수라고도 한다.
- 접근자 프로퍼티는 자체적으로 값을 가지지 않으며 다만 데이터 프로퍼티의 값을 읽거나 저장할 때 관여한다.

**🐥 프로토타입 🐣**

- 프로토타입은 어떤 객체의 상위 객체의 역할을 하는 객체이다. 프로토타입은 자식 객체에게 자신의 프로퍼티와 메서드를 상속한다.
- 프로토타입 객체의 프로퍼티나 메서드를 상속받은 하위 객체는 자신의 프로퍼티 또는 메서드인 것처럼 자유롭게 사용할 수 있다.
- 단방향 링크드 리스트 형태 -> 프로토타입 체인

### 프로퍼티 정의

- 새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의하거나, 기존 프로퍼티의 프로퍼티 어트리뷰트를 재정의하는 것을 말한다.
- Object.definedProperty -> 프로퍼티의 어트리뷰트 재정의

### 객체 변경 방지

- Object.preventExtensions -> 객체의 확장 금지
- Object.seal -> 객체 밀봉 (읽기와 쓰기만 가능하다)
- Object.freeze -> 객체 동결 (동결된 객체는 읽기만 가능하다)
- 객체의 중첩 객체까지 동결하여 변경이 불가능한 읽기 전용의 불변 객체를 구현하려면 객체의 값으로 갖는 모든 프로퍼티에 대해 재귀적으로 Object.freeze 메서드를 호출해야 한다.

# 🐳 생성자 함수에 의한 객체 생성

### Object 생성자 함수

- new 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환한다.
- 생성자 함수란 new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수를 말한다. 생성자 함수에 의해 생성된 객체를 인스턴스라 한다.

### 생성자 함수

- 객체 리터럴에 의한 객체 생성 방식은 직관적이고 간편하다. 하지만 객체 리터럴에 의한 객체 생성은 단 하나의 객체만 생성!
- 동일한 프로퍼티를 갖는 객체를 여러 개 생성해야 하는 경우 생성자 함수를 사용하면 동일한 객체 여러 개를 간편하게 생성할 수 있다.
- new 연산자와 함께 호출하면 해당함수는 생성자 함수로 동작한다. 만약 new 연산자와 함께 생성자 함수를 호출하지 않으면 생성자 함수가 아니라 일반 함수로 동작한다.
- 생성자 함수에서 수행해야 하는 것 -> 인스턴스 생성과 생성된 인스턴스를 초기화 하는 것
- 자바스크립트 엔진은 암묵적인 처리를 통해 인스턴스를 생성하고 반환한다.

- 암묵적으로 빈 객체 생성 -> this에 바인딩 -> 생성자 함수가 생성할 인스턴스를 가리킴 -> this에 바인딩 되어 있는 인스턴스를 초기화
- **바인딩** 식별자와 값을 연결하는 과정을 의미, 변수 선언은 변수이름과 확보된 메모리 공간의 주소를 바인딩하는 것. this 바인딩은 this와 this가 가리킬 객체를 바인딩
- 일반객체는 호출할 수 없지만 함수는 호출이 가능
- callable 호출 할 수 있는 객체, constructor 생성자 함수로서 호출할 수 있는 함수, non-constructor 객체를 생성자 함수로서 호출할 수 없는 함수
- constructor : 함수 선언문, 함수 표현식, 클래스(클래스도 함수)
- non-constructor : 메서드, 화살표 함수
- 일반함수와 생성자 함수 -> this가 가리키는 것이 다르다

# 🥑 함수와 일급 객체

### 일급 객체

- 일급객체의 조건

1. 무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.
2. 변수나 자료구조(객체, 배열 등)에 저장할 수 있다.
3. 함수의 매개변수에 전달할 수 있다.
4. 함수의 반환값으로 사용할 수 있다.

- 자바스크립트의 함수는 위의 조건을 모두 만족하므로 일급 객체이다.
- 함수가 일급 객체라는 것은 함수를 객체와 동일하게 사용할 수 있다는 의미다. 객체는 값이므로 함수는 값과 동일하게 취급할 수 있다.
- 일급객체로서 함수가 가지는 가장 큰 특징은? -> 일반 객체와 같이 함수의 매개변수에 전달할 수 있으며, 함수의 반환값으로 사용할 수도 있다는 것

### 함수 객체의 프로퍼티

- arguments 객체는 인수를 프로퍼티 값으로 소유, 프로퍼티 키는 인수의 순서를 나타낸다.
- arguments 객체는 유사배열 객체 -> 배열이 아니므로 배열 메서드를 사용할 경우 에러가 발생한다.
- caller는 함수 자신을 호출한 함수를 가리킨다.
- length는 함수를 정의할 때 선언한 매개변수의 개수
- name은 함수의 이름을 나타낸다. -> ES5와 ES6에서 동작을 달리하므로 주의

# 🍒 프로토타입

### 객체지향 프로그래밍

- 명령형 프로그래밍의 절차지향적 관점에서 벗어나 여러개의 독립적 단위, 즉 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임이다.
- name, address 등의 속성을 통해 여러개의 값을 하나의 단위로 구성한 복합적인 자료구조를 객체라하며, 객체지향 프로그래밍은 독립적인 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임이다.
- 객체지향 프로그래밍은 객체의 상태를 나타내는 데이터와 상태 데이터를 조작할 수 있는 동작을 하나의 논리적인 단위로 묶어서 생각한다.
- 객체의 상태 데이터 -> 프로퍼티, 동작 -> 메서드라 부른다.

### 상속과 프로토타입

- 상속은 객체지향 프로그래밍의 핵심 개념 -> 프로토타입 기반으로 상속을 구현하여 불필요한 중복을 제거

### 프로토타입 객체

- 프로토타입은 어떤 객체의 상위 객체 역할을 하는 객체로 다른 객체에 공유 프로퍼티(메서드 포함)를 제공한다. 프로토타입을 상속받은 하위 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 자유롭게 사용할 수 있다.
- 모든 객체는 [[Prototype]] 이라는 내부슬롯을 갖는다.
- 모든 객체는 하나의 프로토타입을 갖는다.

### **proto** 접근자 프로퍼티

- 모든 객체는 **proto** 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 [[Prototype]] 내부 슬롯에 간접적으로 접근할 수 있다.
- 접근자 프로퍼티는 자체적으로 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 [[Get]], [[Set]] 프로퍼티 어트리뷰트로 구성된 프로퍼티이다.
- **proto** 접근자 프로퍼티는 상속을 통해 사용된다.
- 프로토타입 체인은 단방향 링크드 리스트로 구현되어야 한다. 프로퍼티 검색 방향이 한쪽 방향으로만 흘러가야함! (**proto** 접근자 프로퍼티를 통해 간접적으로 접근하는 이유)
- **proto** 접근자 프로퍼티를 사용할 수 없는 경우가 있기 때문에 Object.setPrototypeOf 메서드 사용하는 것을 권장
- 함수 객체만이 소유하는 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다. -> 일반 객체는 prototype 프로퍼티를 소유하지 않는다.
- 생성자 함수로 호출할 수 없는 함수, 즉 non-constructor인 화살표 함수와 메서드는 prototype 프로퍼티를 소유하지 않으며 프로토타입도 생성하지 않는다.
- 모든 객체가 가지고 있는 **proto** 접근자 프로퍼티와 함수 객체만이 가지고 있는 prototype 프로퍼티는 결국 동일한 프로토타입을 가리킨다.

### 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입

- 생성자 함수에 의해 생성된 인스턴스는 프로토타입의 constructor 프로퍼티에 의해 생성자 함수와 연결된다.
- 프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재한다.

### 프로토타입의 생성 시점

- 프로토타입은 생성자 함수가 생성되는 시점에 더불어 형성된다.
- 생성자 함수는 사용자가 직접 정의한 사용자 정의 생성자와 자바스크립트가 기본 제공하는 빌트인 생성자가 있다.
- 일반 함수로 정의한 함수 객체는 new 연산자와 함께 생성자 함수로 호출 가능
- 생성자 함수로 호출할 수 있는 함수, 즉 constructor는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성
- non-constructor는 프로토타입 생성되지 않음!
- 빌트인 생성자 함수가 아닌 사용자 정의 생성자 함수는 자신이 평가되어 함수 객체로 생성되는 시점에 프로토타입도 더불어 생성! -> Object.prototype
- Object, String, Number, Function, Array, Date, Promise등과 같은 빌트인 생성자 함수도 일반 함수와 마찬가지로 빌트인 생성자 함수가 생성되는 시점에 프로토타입이 생성

### 프로토타입 체인

- 자바스크립트는 객체의 프로퍼티에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 [[Prototype]] 내부 슬롯의 참조를 따라 자신의 부모 역하을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 이를 프로토타입 체인이라 한다. 프로토타입 체인은 자바스크립트가 객체지향 프로그래밍의 상속을 구현하는 매커니즘이다.
- 프로토타입 체인의 최상위 객체는 언제나 Object.prototype이다.
- Object.prototype을 프토토타입 체인의 종점이라한다.
- 프로토타입 체인은 상속과 프로퍼티 검색을 위한 매커니즘, 스코프 체인은 식별자 검색을 위한 매커니즘

### 오버라이딩과 프로퍼티 섀도잉

- 오버라이딩은 상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의하여 사용하는 방식
- 상속 관계에 의해 프로퍼티가 가려지는 현상을 프로퍼티 섀도잉
- 하위 객체를 통해 프로퍼티를 변경 또는 삭제하는 것은 불가능 -> 하위 객체를 통해 프로토타입에 get 액세스는 허용되지만 set은 허용되지 않음

### 프로토타입의 교체

- 프로토 타입은 임의의 다른 객체로 변경이 가능 -> 상속관계 동적으로 변경
- 인스턴스의 **proto** 접근자 프로퍼티를 통해서도 프로토타입을 교체할 수 있다.

### instanceof 연산자

- 우변의 생성자 함수의 prototype에 바인딩된 객체가 좌변의 객체의 프로토타입 체인 상에 존재하면 true, 그렇지 않으면 false로 평가된다.
- instanceof 연산자는 생성자 함수의 prototype에 바인딩된 객체가 프로토타입 체인 상에 존재하는지 확인한다.

### 직접 상속

- Object.create 메서드는 첫 번째 매개변수에 전달한 객체의 프로토타입 체인에 속하는 객체를 생성한다.
- **proto** 접근자를 사용하여 직접 상속을 구현

### 정적 프로퍼티/메서드

- 정적 프로퍼티/메서드는 생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/메서드를 말한다.
- 표기법만으로도 정적 프로퍼티/메서드와 프로토타입 프로퍼티/메서드를 구분할 수 있음

- in 연산자를 사용하면 객체 내에 특정 프로퍼티가 존재하는지 여부를 확인할 수 있다.
- Object.prototype.hasOwnProperty를 사용해도 객체에 특정 프로퍼티가 존재하는지 확인할 수 있다.
- 객체의 모든 프로퍼티를 순회하며 열거하려면 for...in문을 사용 -> 프로퍼티 어트리뷰터 [[Enumerable]]의 값이 true인 프로퍼티를 순회하며 열거한다.

# 🥯 strict mode

### strict mode란?

- ES6에서 추가된 모드로, 자바스크립트 언어의 문법을 좀 더 엄격히 적용하여 오류를 발생시킬 가능성이 높거나 자바스크립트 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 명시적인 에러를 발생시킨다.

- 전역에 strict mode를 적용하는 것은 피하자.
- 함수 단위로 strict mode를 적용시키는 것도 피하자 -> 일일이 적용하는 것 번거로움]

# 🧃 빌트인 객체

### 자바스크립트 객체의 분류

- 표준 빌트인 객체 : 실행환경과 관계없이 언제나 사용 가능, 표준 빌트인 객체는 전역 객체의 프로퍼티로서 제공된다. 별도의 선언 없이 전역 변수처럼 언제나 참조할 수 있다.
- 호스트 객체 : 자바스크립트 실행 환경에서 추가로 제공하는 객체
- 사용자 정의 객체 : 표준 빌트인 객체와 호스트 객체처럼 기본 제공되는 객체가 아닌 사용자가 직접 정의한 객체

### 표준 빌트인 객체

- Object, String, Number, Boolean 등 40여개의 표준 빌트인 객체가 제공됨

### 원시값과 래퍼 객체

- 문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 객체 래퍼라고 한다.
- 예를들어 래퍼 객체인 String 생성자 함수의 인스턴스가 생성되면 문자열은 래퍼 객체의 [[StringData]] 내부 슬롯에 할당 -> string.prototype의 메서드 상속 -> 래퍼 객체 처리가 종료되면 [[StringData]] 내부 슬롯에 할당된 원시값으로 원래의 상태, 즉 식별자가 원시값을 갖도록 되돌리고 래퍼 객체는 가비지 컬렉션의 대상이 된다.
- symbol도 래퍼 객체를 생성
- null, undefined는 래퍼 객체를 생성하지 않는다.

### 전역 객체

- 전역 객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며, 어떤 객체에도 속하지 않은 최상위 객체
- 브라우저 환경에서는 window, Node.js 환경에서는 global이 전역 객체를 가리킨다
- 전역 객체는 개발자가 의도적으로 생성할 수 없고, 전역 객체를 생성할 수 있는 생성자 함수가 제공되지 않는다.
- 전역 객체의 프로퍼티를 참조할 때 window(또는 global)를 생략할 수 있다.
- 브라우저 환경의 모든 자바스크립트 코드는 하나의 전역 객체 window를 공유한다.
- 빌트인 전역 프로퍼티는 저역 객체의 프로퍼티이며, 주로 애플리케이션 전역에서 사용하는 값을 제공한다.

# 🌰 this

### this 키워드

- 객체는 상태를 나타내는 프로퍼티와 동작을 나타내는 메서드를 하나의 논리적인 단위로 묶은 복합적인 자료 구조이다.
- 동작을 나타내는 메서드는 자신이 속한 객체의 상태, 즉 프로퍼티를 참조하고 변경할 수 있어야 한다. 이때 메서드가 자신이 속한 객체의 프로퍼티를 참조하려면 먼저 자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야 한다.
- this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다.

### 함수 호출 방식과 this 바인딩

- 일반 함수로 호출된 모든 함수(중첩 함수, 콜백 함수 포함) 내부의 this에는 전역 객체가 바인딩된다.
- 메서드 호출은 메서드를 호출한 객체에 바인딩 된다.
- 생성자 함수로 호출된 함수는 생성자 함수가 (미래에) 생성할 인스턴스에 바인딩 된다.
- Function.prototype.apply/call/bind 메서드에 의해 간접 호출된 함수들은 메서드에 첫번째 인수로 전달한 객체에 바인딩 된다.
