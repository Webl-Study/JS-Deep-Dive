# 클래스
<br>

- **자바스크립트는 프로토타입 기반 객체지향 언어**
- 프로토타입 기반 객체지향 언어는 클래스가 필요 없는 객체지향 프로그래밍 언어다.
- ES5에서는 클래스 없이도 다음과 같이 **생성자 함수와 프로토타입을 통해 객체지향 언어의 상속을 구현할 수 있다.**
<br>

- **클래스와 생성자 함수는 모두 프로토타입 기반의 인스턴스를 생성**하지만 **동일하게 동작하지 않는다.**
- 클래스는 생성자 함수보다 엄격하며 생성자 함수에서는 제공하지 않는 기능도 제공한다.
<br>

- 클래스는 프로토타입 기반 객체 생성 패턴의 **새로운 객체 생성 메커니즘** 이다.
- **클래스의 extends와 super 키워드는 상속 관계 구현을 더욱 간결하고 명료하게 한다.**
<br>
<br>

### 클래스와 생성자 함수의 차이점
1. - 클래스를 new 연산자 없이 호출하면 에러가 발생<br>
    - 생성자 함수를 new 연산자 없이 호출하면 일반 함수로서 호출
<br>

2.
    - 클래스는 상속을 지원하는 extends와 super 키워드를 제공
<br>

3.
    - 클래스는 호이스팅이 발생하지 않는 것처럼 동작
    - 함수 선언문으로 정의된 생성자 함수는 함수 호이스팅이, 함수 표현식으로 정의한 생성자 함수는 변수 호이스팅 발생
<br>

4.
    - 클래스 내의 모든 코드에는 암묵적으로 strict mode가 지정되어 실행되며 strict mode를 해제할 수 없다.
<br>

5.
    - 클래스의 constructor, 프로토타입 메서드, 정적 메서드는 모두 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false다.<br>
= 열거되지 않는다.
<br>
<br>

## 클래스 정의
- 클래스는 class 키워드를 사용하여 정의한다.
- 일반적이지는 않지만 **함수와 마찬가지로 표현식으로 클래스를 정의할 수 있다.** <br>
= **클래스를 표현식으로 정의할 수 있다는 것은 클래스가 값으로 사용할 수 있는 일급 객체라는 것** <br>
<br>

### 클래스가 일급 객체라서 갖는 특징
1. 무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.
2. 변수나 자료구조(객체, 배열)에 저장할 수 있다.
3. 함수의 매개변수에게 전달할 수 있다.
4. 함수의 반환값으로 사용할 수 있다.
<br>
<br>

## 클래스 호이스팅
- 클래스는 함수로 평가된다.
<br>

- **클래스 선언문으로 정의한 클래스는** 함수 선언문과 같이 **소스코드 평가 과정, 즉, 런타임 이전에 먼저 평가되어 함수 객체를 생성**한다.<br>
=> 이때 클래스가 평가되어 생성된 함수 객체는 생성자 함수로서 호출할 수 있는 함수, 즉 **constructor**다.<br>

- **생성자 함수로서 호출할 수 있는 함수는** 함수 정의가 평가되어 **함수 객체를 생성하는 시점에 프로토타입도 더불어 생성**된다.
- 프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재하기 때문
- 단, **클래스는 클래스 정의 이전에 참조할 수 없다.**
<br>

- **클래스는 let, const 키워드로 선언한 변수처럼 호이스팅 된다.**
- 따라서 클래스 선언문 이전에 일시적 사각지대(TDZ)에 빠지기 때문에 호이스팅이 발생하지 않는 것처럼 동작한다.
<br>
<br>

## 인스턴스 생성
- **클래스는 생성자 함수이며 new 연산자와 함께 호출되어 인스턴스를 생성** 한다.
- 함수는 new 연산자의 사용 여부에 따라 일반 함수 or 인스턴스 생성을 위한 생성자 함수로 호출되지만,<br>
**클래스는 인스턴스를 생성하는 것이 유일한 존재 이유**이므로 **반드시 new 연산자와 함께 호출**해야 한다.
<br>
<br>

## 메서드
- 클래스 몸체에는 0개 이상의 메서드만 선언할 수 있다.
- **클래스 몸체에서 정의할 수 있는 메서드는 constructor, 프로토타입 메서드, 정적 메서드**
<br>

여기 디테일하게 다시 정리
<br>
<br>

## 클래스의 인스턴스 생성 과정

## 프로퍼티
- **인스턴스 프로퍼티는 언제나 public**

### 접근자 프로퍼티
- 접근자 프로퍼티는 **자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수**, 즉 **getter 함수와 setter 함수로 구성**되어 있다.
<br>

- **getter는 인스턴스 프로퍼티에 접근할 때마다**, 프로퍼티 값을 조작하거나 별도의 행위가 필요할 때 사용
- **setter는 인스턴스 프로퍼티에 값을 할당할 때마다**, 프로퍼티 값을 조작하거나 별도의 행위가 필요할 때 사용
<br>

- **클래스의 메서드는 기본적으로 프로토타입 메서드**가 된다.<br>
따라서 **클래스의 접근자 프로퍼티** 또한 인스턴스 프로퍼티가 아닌 **프로토타입의 프로퍼티**가 된다.<br>
<br>
<br>

### private 필드 정의 제안
- 자바스크립트는 캡슐화를 완전하게 지원하지 않는다
- private, public, protected 키워드와 같은 접근 제한자를 지원하지 않는다.<br>
따라서, **인스턴스 프로퍼티는 인스턴스를 통해 클래스 외부에서 언제나 참조할 수 있다. = 언제나 public**
<br>
<br>

- 타입스크립트는 클래스 기반 객체지향 언어가 지원하는 접근 제한자인 public, private, protected를 모두 지원
<br>
<br>

## 상속에 의한 클래스 확장
### 클래스 상속과 생성자 함수 상속
- **상속에 의한 클래스 확장은 지금까지 살펴본 프로토타입 기반 상속과는 다른 개념**이다.
- 프로토타입 기반 상속은 프로토타입 체인을 통해 다른 객체의 자산을 상속받는 개념이지만,<br>
**상속에 의한 클래스 확장은 기존 클래스를 상속받아 새로운 클래스를 확장하여 정의하는 것** 이다.
<br>

- **클래스와 생성자 함수는 인스턴스를 생성할 수 있는 함수라는 점에서 매우 유사**
- 하지만 클래스는 상속을 통해 기존 클래스를 확장할 수 있는 문법이 기본적으로 제공된다.
<br>

- **상속에 의한 클래스 확장은 코드 재사용 관점에서 매우 유용**하다.
<br>
<br>

### extends 키워드
- 서브클래스(자식 클래스) : 상속을 통해 확장된 클래스
- 수퍼클래스(부모 클래스) : 서브 클래스에게 상속된 클래스
<br>

- **extends 키워드의 역할 : 수퍼클래스와 서브클래스 간의 상속 관계를 설정**
- 클래스도 프로토타입을 통해 상속 관계를 구현한다.
- **수퍼클래스와 서브클래스는 인스턴스의 프로토타입 체인뿐 아니라 클래스 간의 프로토타입 체인도 생성**한다.<br>
**이를 통해 프로토타입 메서드, 정적 메서드 모두 상속이 가능** 하다.
<br>
<br>

### super 키워드
- super 키워드는 함수처럼 호출할 수도 있고 this와 같이 식별자처럼 참조할 수 있는 특수한 키워드다.
<br>

#### super 호출
- **super를 호출하면 수퍼클래스의 constructor(super-constructor)를 호출한다.**
<br>

- 수퍼클래스에서 추가한 프로퍼티와 서브클래스에서 추가한 프로퍼티를 갖는 인스턴스를 생성한다면 서브클래스의 constructor를 생략할 수 없다.
<br>
<br>

#### super를 호출할 때 주의할 사항
1. 서브클래스에서 constructor를 생략하지 않는 경우, 서브클래스의 constructor에서는 반드시 super를 호출해야한다.<br>
2. 서브클래스의 constructor에서 super를 호출하기 전에는 this를 참조할 수 없다.
3. super는 반드시 서브클래스의 constructor에서만 호출한다.
<br>

#### super 참조
- **super를 참조하면 수퍼클래스의 메서드를 호출할 수 있다.**
<br>

- 주의할 것은 **ES6의 메서드 축약 표현으로 정의된 함수만이 [[HomeObject]]를 갖는다**는 것
- [[HomeObject]]를 가지는 함수만이 super를 참조할 수 있다.
- super 참조는 클래스의 전유물은 아니다. <br>
**객체 리터럴에서도 super 참조를 사용할 수 있다. 단 ES6의 메서드 축약 표현으로 정의된 함수만 가능**하다.
<br>
<br>

### 상속 클래스의 인스턴스 생성 과정

이건 다시 보고.. 다시 정리하기

<br>
<br>




