# 🍧 객체 리터럴

### 객체란?

- 자바스크립트를 구성하는 거의 모든 것이 '객체' 입니다. 원시값을 제외한 나머지 값은 모두 객체!
- 객체 타입은 다양한 타입의 값을 하나의 단위로 구성한 복합적인 자료 구조이다.
- 원시값은 변경 불가능하지만, 객체는 변경이 가능한 값!

  <img width="329" alt="image" src="https://github.com/Webl-Study/JS-Deep-Dive/assets/111405347/460306e3-6211-45fd-995a-ed041959b697">

- 객체는 위 그림과 같이 0개 이상의 프로퍼티로 구성 되며, 프로퍼티는 key와 value(값)로 구성된다.
- 자바스크립트 함수는 '일급객체' 이므로 값으로 취급할 수 있다는 말은 -> 함수가 다른 객체와 마찬가지로 다루어진다는 뜻이다.

  - 일급객체 특징
    - 함수를 변수에 할당할 수 있다.
    - 함수를 다른 함수에 전달할 수 있다.
    - 함수가 다른 함수의 반환값이 될 수 있다.
    - 함수를 객체에 저장할 수 있다.

- 객체는 프로퍼티와 메서드로 구성이 되며, 프로퍼티는 객체의 상태를 나타내는 값/ 메서드는 프로퍼티를 참조하고 조작할 수 있는 동작이다.

### 객체 리터럴에 의한 객체 생성

- 자바스크립트는 프로토타입 기반의 객체지향 언어로 다양한 객체 생성 방법을 지원한다.
- 이 중 가장 일반적이고 간단한 방법은 객체 리터럴을 사용하는 것! -> {} 중괄호 내에 0개 이상의 프로퍼티를 정의하는 것이다.
- 만약 중괄호 내에 프로퍼티를 정의하지 않으면 빈 객체가 생성된다.
- 객체 리터럴 덕분에 자바스크립트에서 객체를 생성하기 위해 클래스를 먼저 정의하고 new 연산자와 함께 생성자를 호출할 필요가 없다.

### 프로퍼티

- **객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다.**
- 프로퍼티 키는 프로퍼티 값에 접근할 수 있는 이름으로 식별자 역할을 한다.
- 식별자 네이밍 규칙을 따르지 않으면 자바스크립트 엔진이 다르게 해석할 가능성이 있다.
  - 예를들어) last-name이라고 프로퍼티 키를 사용하면, - 를 연산자로 해석
- 프로퍼티 키로 숫자 리터럴을 사용하면 따옴표는 안 붙지만 내부적으로는 문자열로 변환된다.
- var, function 과 같은 예약어를 써도 에러는 발생하지 않지만, 예상치 못한 에러가 발생할 여지가 있으므로 권장하지 않음
- 이미 존재하는 프로퍼티 키를 중복 선언하면 나중에 선언한 프로퍼티가 먼저 선언한 프로퍼티를 덮어쓴다 -> 에러를 발생하지는 않음

### 메서드

- 프로퍼티 값이 함수일 경우도 있기 때문에, 일반 함수와 구분하기 위해 객체 내에 있는 함수를 메서드라 부른다.

### 프로퍼티 접근

- 프로퍼티에 접근하는 두가지 방법은 -> 마침표를 쓰는 '마침표 표기법' / 대괄호 프로퍼티를 사용하는 '대괄호 표기법'
- 객체에 존재하지 않는 프로퍼티에 접근하면 undefined를 반환한다. ReferenceError가 발생하지 않는다는 점!

# 🛼 원시 값과 객체의 비교

- 원시타입은 변경 불가능한 값, 이에 비해 객체 타입은 변경 가능한 값이다.
- 원시 값을 변수에 할당하면 변수에는 실제 값이 저장! 객체를 변수에 할당하면 변수에는 참조 값이 저장된다!
- 원시 값의 변수에 다른 변수를 할당하면 원시 값이 복사되어 전달 (값에 의한 전달), 그러나 객체에 다른 변수를 할당하면 참조 값이 복사되어 전달 (참조에 의한 전달)

### 원시 값

- 변수란? 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이다.
- 값은? 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과!
- **변경 불가능하다는 것은 변수가 아니라 값에 대한 것**
- const 키워드를 사용해 선언한 변수는 재할당이 금지되지만, const를 사용해서 선언한 변수에 할당한 객체는 변경할 수 있다.
- 원시값을 저장하려면 먼저 확보해야 하는 메모리 공간의 크기를 결정해야 한다.
- **유사 배열 객체란?**

  - 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체이다
  - 문자열은 유사 배열이므로 배열과 유사하게 인덱스를 사용해서 문자에 접근이 가능

- 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있다.

### 객체

- 객체는 프로퍼티의 개수가 정해져 있지 않으며, 동적으로 추가되고 삭제할 수 있다. 또한 프로퍼티의 값에도 제약이 없다. 따라서 객체는 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다.
- 객체는 변경 가능한 값
- 객체를 할당한 변수를 참조하면 메모리에 저장되어 있는 참조 값을 통해 실제 객체에 접근!
- '변수는 객체를 참조하고 있다' '변수는 객체를 가리키고 있다'
- 객체는 변경 가능한 값이기 때문에, 객체를 할당한 변수에 재할당을 하지 않으므로 객체를 할당한 변수의 참조 값 자체는 변경되지 않는다!
- 객체가 변경 가능한 값인 이유는? 객체는 크기가 일정하지 않고, 크키가 매우 클수도 있기 때문에 복사해서 생성하는 비용이 많이듬! 따라서 메모리를 효율적으로 사용하기 위해 객체를 복사해서 생성
- 그러나 단점은 여러개의 식별자가 하나의 객체를 공유할 수 있다는 것이다.

- **얕은복사와 깊은복사**

  - 얕은 복사는 객체의 참조 값을 복사, 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사해서 원시 값처럼 완전한 복사본을 만든다.
  - 원시 값을 할당한 변수를 다른 변수에 할당하는 것을 깊은 복사, 객체를 할당한 변수를 다른 변수에 할당하는 것을 얕은 복사라고 부르는 경우도 있다.
  - 물건의 예시를 들어본다면, 얕은 복사는 원본 물건과 복사본 안에 든 물건을 같이 사용. 깊은 복사는 물건 안에 또다른 물건이 있다면, 그 안에 있는 물건을 모두 모두 따로 복사한다!

- 객체를 다른 변수에 할당하면 두 개의 식별자가 하나의 객체를 공유한다. 따라서 원본 또는 사본 중 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다.

# 🎨 함수

### 함수란?

- 자바스크립트에서 가장 중요한 개념!
- 함수는 일련의 과정을 '문'으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것
- 함수 내부로 입력을 전달 받는 변수를 매개변수, 입력을 인수, 출력을 반환값(return value)라고 한다.
  <img width="489" alt="image" src="https://github.com/Webl-Study/JS-Deep-Dive/assets/111405347/6fc9b026-df84-4461-9c97-046c82cfe3e6">

- 인수를 전달하면서 함수를 호출하는 것

### 함수를 사용하는 이유

- 함수는 필요할 때 여러번 호출할 수 있다. -> 코드의 재사용이라는 측면에서 매우 유용하다.
- 함수는 코드의 중복을 억제하고 재사용성을 높인다. 또한 유지보수의 편의성을 높이고 실수를 줄여준다.

### 함수 리터럴

- 함수는 function 키워드, 함수 이름, 매개변수 목록, 함수의 몸체로 구성된다.
- 함수이름은 생략할 수 있다. (무기명 or 익명함수)
- 매개변수의 목록은 순서에 의미가 있다.
- 함수와 일반 객체의 다른 점은? -> 일반 객체는 호출할 수 없지만 함수는 호출할 수 있다. 또한 일반 객체에는 없는 함수만의 고유 프로퍼티를 갖는다.

### 함수 정의

- 함수를 정의하는 방법은 4가지! 함수 선언문, 함수 표현식, Function 생성자 함수, 화살표 함수
- {} 중의적인 코드는 코드의 문맥에 따라 해석이 달라진다. {} 단독으로 존재하면 블록문으로 해석, 값으로 평가되어야 할 문맥에서 피연산자로 사용되면 객체 리터럴로 해석
- 함수 foo()를 외부에서 호출할 수 있는 이유는? (foo가 식벼자가 아니어도 되는이유) -> 자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다.
- 함수는 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다!
- 자바스크립트의 함수는 값처럼 변수에 할당할 수도 있고 프로퍼티 값이 될 수도 있으며 배열의 요소가 될 수도 있다. 이처럼 값의 성질을 갖는 객체를 일급객체라함! -> 함수를 값처럼 자유롭게 사용할 수 있다는 의미이다.

- 함수 선언문의로 정의한 함수는 함수 선언문 이전에 호출할 수 없다. 그러나 함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출 할 수 있다. -> 생성 시점이 다름
- 변수는 undefined로 초기화 되지만, 함수 선언문을 통해 생성된 식별자는 함수 객체로 초기화된다.
- 그러나 함수 표현식으로 생성된 함수는 변수 호이스팅이 발생한다.

### 함수 호출

- 함수의 인수는 값으로 평가될 수 있는 표현식이어야 한다. 인수는 함수를 호출할 때 지정하며, 개수와 타입에 제한이 없다.
- 매개변수의 스코프(유효범위)는 함수 내부!
- 함수 매개변수의 개수와 인수는 일치해야 한다.
- 매개변수보다 인수가 더 많은 경우 초과된 인수는 무시됨! -> 버려지는 것이 아니라 암묵적으로 보관된다
- 매개변수가 많다는 것은 함수가 여러 일을 한다는 것 -> 이상적인 함수는 한 가지 일만 해야 하며 가급적 작게 만들어야 한다.

### 다양한 함수의 형태

- 즉시 실행 함수는 함수 정의와 동시에 즉시 호출되며 단 한번만 호출 가능
- 즉시 실행 함수는 익명함수를 사용하는 것이 일반적
- 자기 자신을 호출하는 것이 재귀 함수
- 재귀함수를 사용하면 반복되는 처리를 반복문 없이 구현할 수 있다.
- 재귀 함수는 무한 호출을 하기 대문에 탈출 조건을 반드시 만들어야 함
- 함수 내부에 정의된 함수는 중첩함수 또는 내부 함수라 한다.
- 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백함수라 하고, 매개 변수를 통해 함수의 외부에서 콜백 함수를 전달 받은 함수를 고차함수라 한다.

### 순수함수와 비순수함수

- 순수함수는 외부 상태에 의존하지 않고 동일한 인수가 전달되면 언제나 동일한 값을 반환하는 함수
- 반대로 함수의 외부 상태에 따라 반환값이 달라지는 함수를 비순수 함수라고 한다.

# 🚗 스코프

### 스코프란?

- 매개변수는 함수 몸체 내부에서만 참조할 수 있다 -> 스코프
- 변수는 자신이 선언된 위치에 의해 자신이 유효한 범위, 즉 다른 코드가 변수 자신을 참조할 수 있는 범위가 결정된다. 모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다. 이를 스코프라 한다!

### 스코프의 종류

- 전역과 지역으로 구분
- 전역에서 선언된 변수는 전역 스코프를 갖는 전역 변수, 지역에서 선언된 변수는 지역 스코프를 갖는 지역 변수이다.
- 지역 스코프에서 찾는 지역 변수가 없을때, 점점 스코프가 위로 올라감 지역-> 전역으로
- 전역 변수는 어디에서든지 참조가 가능
- 지역 스코프는 자신의 지역 스코프와 하위 지역 스코프에서 유효하다

### 스코프 체인

- 함수는 중첩될 수 있고, 함수의 지역 스코프도 중첩될 수 있다. -> 스코프가 함수의 중첩에 의해 계층적 구조를 갖는다는 것을 의미한다.
- 모든 지역 스코프의 최상위 스코프는 전역 스코프이며, 스코프가 계층적으로 연결된 것을 스코프 체인이라고 한다.
- 스코프 체인은 실행 컨텍스트의 렉시컬 환경을 단방향으로 연결한 것이다.
- 상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 하위 스코프에서 유효한 변수는 상위 스코프에서 참조할 수 없다.

### 함수 레벨 스코프

- 모든 코드 블록이 만드는 것을 블록 레벨 스코프라 한다. 하지만 var 키워드로 선언된 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다. 이러한 특성을 함수 레벨 스코프라고 한다.
- var 키워드로 선언된 변수는 함수 레벨 스코프만 인정하기 때문에 함수 밖에서 var 키워드로 선언된 변수는 코드 블록 내에서 선언되었다 해도 모두 전역 변수이다.

### 렉시컬 스코프

- 함수를 어디에서 호출했는지가 아니라 함수를 어디서 정의했는지에 따라 스코프럴 결정하는 것
- 함수가 호출된 위치는 상위 스코프 결정에 어떠한 영향도 주지 않는다.

# 🎠 전역 변수의 문제점

- 전역변수의 무분별한 사용은 위험하기 때문에 반드시 사용해야 하는게 아니라면 지역 변수를 사용해야 한다.

### 변수의 생명 주기

- 변수는 생성 되고, 할당을 통해 값을 갖고, 언젠가 소멸한다 -> 변수는 생명주기(life cycle)가 있다.
- 전역 변수의 생명주기는 애플리케이션의 생명주기와 같다.
- 함수 내부에서 선언된 지역변수는 함수가 호출되면 생성되고, 함수가 종료하면 소멸한다.
- 변수선언은 런타임에 실행되는 것이 아니라 런타임 이전 단계에서 자바스크립트 엔진에 의해 먼저 실행!
- 지역변수의 생명 주기는 함수의 생명주기와 일치한다.
- **호이스팅** 변수 선언이 스코프의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트의 특징!
- 전역객체 : 자바스크립트 엔진에 의해 먼저 생성된 특수한 객체로 window, global 객체등이 있다.

### 전역 변수의 문제점

- 전역 변수는 생명 주기가 길다. 따라서 메모리 리소스도 오랜 기간 소비한다.
- 또한 var 키워드는 변수의 중복 선언을 허용하므로 생명주기가 긴 전역 변수는 변수 이름이 중복될 가능성이 있다. -> 의도하지 않은 재할당
- 전역 변수는 스코프 체인 상에서 종점에 존대! 즉 전역 변수가 가장 마지막에 검색된다 -> 전역 변수의 검색 속도가 가장 느리다.
- 다른 파일에서 동일한 이름으로 명명된 전역 변수나 전역 함수가 같은 스코프 내에 존재하면 예상치 못한 결과를 가져온다.

### 전역 변수의 사용을 억제하는 방법

- 변수의 스코프는 좁을 수록 좋음
- 즉시 실행함수를 사용
- 네임스페이스 객체 사용
- 모듈 패턴 -> 관련이 있는 변수와 함수를 모아서 즉시 실행 함수로 감싸 하나의 모듈을 만든다. (클로저 기반으로 동작)
- ES6 모듈 사용 -> 전역 변수를 사용할 수 없다. ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공한다.

# 🕯️ let, const 키워드와 블록 레벨 스코프

### var 키워드로 선언한 변수의 문제점

- var 키워드로 선언한 변수는 중복 선언이 가능하다.
- var 로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다. 따라서 함수 외부에서 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 된다.
- for 문의 변수 선언문에서 var로 선언한 변수도 전역 변수가 된다.

### let 키워드

- var의 단점을 보완하기 위해 ES6에서 등장
- let 키워드로 이름이 같은 변수를 중복 선언하면 에러 발생
- let은 모든 코드블록 (함수, if문, for문, while문, true/catch문 등)을 지역 스코프로 인정하는 블록 레벨 스코프이다.
- 선언문 이전에 참조하면 참조 에러가 발생한다.
- 스코프 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간을 일시적 사각지대 TDZ라고 부른다.

### const 키워드

- const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화 해야한다. (초기화와 할당을 함께 해야함)
- 재할당 금지
- 값을 변경할 수 없기 때문에 상수를 표현하는 데 사용
- const 키워드는 재할당을 금지할 뿐 '불변'은 아니기 때문에, 프로퍼티 동적 생성, 삭제, 값의 변경을 통해 객체를 변경하는 것은 가능하다.
